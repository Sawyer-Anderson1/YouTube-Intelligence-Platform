[
    {
        "text": " The Claude Code team have recently announced custom tool support and hooks to Claude Code SDK, making it one step easier for you to create your own custom agent for your specific needs. And with some companies now hiring AI agents instead of actual humans, it's more important than ever to know how to build a basic agent. But what makes custom tools and hooks so important? and how do I even get started building an agent with the Claude Code SDK? I'll answer all these questions. And before we get started, make sure you hit that subscribe button. So, this is a really basic example of using the Claude Code SDK. As you can see, we're importing the same library that we would if we were using the Claude Code CLI, which is really cool. From here, we're taking the query function and below it, we're passing in the argument of prompt, which is what model is this? And then from there we're console logging the result. This if statement here is used to make sure that we don't get any type errors from TypeScript. So if we run this file we just get the name of the model that's being used. We could add a specific model in options like claude haiku. And that is the model that will be used for future prompts. And if we wanted to see the full message, we could get rid of results. And we can see all the information we get back from the actual result to the session ID, the token usage, cost, and much more. This is pretty awesome because we get access to all of clawed code hooks and tools, which I'll show you later. But right now, this basic example is only useful for a single prompt. If we wanted to have something more complicated, we'd have to use a different approach known as streaming input mode, which is the mode recommended by Anthropic. To do that, we'd have to create a generator function that yields an object with the type message and a bunch of other things to keep Typescript happy, like the parent tool use ID, the session ID, and setting type and ro to as const. We need to yield one of these objects each time we want to send a prompt to the model. So, this has two prompts. The first one is to ask how many files are in this project, then to multiply that number by five. And if we run this script, we just get the result because that's the only thing we're printing. But there are actually a lot of things taking place like using tools to count the number of files. So if we update the code to print out everything is doing, we can see we get a lot more information including possible tool calls and then the actual result. So let's expose this information, but also let's make it so",
        "start": 0.0,
        "duration": 313.19899999999996
    },
    {
        "text": "like using tools to count the number of files. So if we update the code to print out everything is doing, we can see we get a lot more information including possible tool calls and then the actual result. So let's expose this information, but also let's make it so to the model after it's given me a result. And now we've updated the code to do that. So first we're getting the user input which is just using the standard in. Then once we have an input, we'll pass that value into the content which will be the prompt. From there the agent will return the result and then ask the human for a follow-up prompt. If the agent uses any tools, we'll also print that out as well so we can see the exact tool that's been used. So if we run the script, we get this box with a welcome message and the option for the human to add a prompt. Note the box and the colors were done with this code. Let's give it a prompt like how many files are in this project excluding the node modules directory. And we can see it's used the bash tool then the glob tool before giving us a response and asking us to prompt again. This is actually very impressive. I mean we've built the beginnings of claude code itself and we've only used one function from the SDK with a single file that has 91 lines of code. But we can make this even better. The beauty of creating a custom agent is that you can overwrite the system prompt, making it completely different from the default clawed code. Looking at the Claude SDK documentation, there are several ways you can change the system prompt from using output styles to append system prompt to custom system prompt. And this option is the only one that gives you complete control over the system prompt. Output styles gives you more features, but this option, in my opinion, allows you to truly create your own agent. Let me give you an example. Here we have a custom prompt that tells Claude to always respond with, \"I don't know.\" And then respond with even angrier responses the more prompts the user gives it. So, we can ask, \"What model is this?\" And Claude responds with, \"I don't know.\" But what's even interesting is that if we ask it how many files are in this project, it also responds with, \"I don't know.\" but it doesn't even attempt to make any tool calls. This is because the default system prompt includes tool usage instructions and available tools. So, our custom system prompt has limited the amount of tools that Claude will use. This is really cool because you could create a custom agent for absolutely anything. An agent specific to your kids maths homework that doesn't give them the answer but teaches them instead or an internal company agent",
        "start": 156.64,
        "duration": 593.84
    },
    {
        "text": "custom system prompt has limited the amount of tools that Claude will use. This is really cool because you could create a custom agent for absolutely anything. An agent specific to your kids maths homework that doesn't give them the answer but teaches them instead or an internal company agent one more awesome feature of the claude code SDK which is custom tools. For this I'm using the create SDK MCP server function which has a name version and also uses the tool function from the same claude code SDK. And here we're creating a single tool for our MCP server which takes in an input using ZOD of size drink type extras and currency. Then there are prices associated with the size and the extras. And then it calculates the total price of the drink based on the user prompt which the model figures out from the tool description. Then in the index.ts file, I import the exported custom server and add it to the allowed tools in this format. I've also appended it to the system prompt so that Claude gives me a short answer. So if we wanted the price of a medium oat milk latte, then that should be 4.6. And if we ask the model, it first uses our MCP tool before giving us a result of $4.60. Now, this may seem like a trivial example, but imagine that this is data from a database in a tool that you use or an internal function specific to your app. Now, I could go on and on adding more things to our project because the Claude Code SDK has so many features from handling permissions, showing a to-do list of tasks the agent is going to complete using slash commands, sub aents, session management so you can return to previous conversations, and even specifying custom hooks. Although, if you already have global clause code hooks, output styles, or sub agents, your custom agent has access to those, too. But I think this is a good place to stop. What are your thoughts on the SDK? Is it something you think you'll use or will you just stick with the regular clawed code? Let me know in the comments. And until next time, happy coding.",
        "start": 299.28,
        "duration": 815.1179999999998
    }
]